# socket 编程：



# <1>.BIO  即阻塞IO

## 1.同步阻塞io

参考代码示例：SyncBlockServer

流程说明：服务端接收一个连接，处理完成之后，在接收下一个连接，目前这种方式基本上没人使用。

举例说明：一个饭店只有一张桌子，一个服务员，一次性只能接待一位顾客进来吃饭，待顾客吃完饭后，请下一位顾客进来。显然这个饭店效率太低，明显赚不到钱，饭店的场地也空闲着。于是老板想改进这种状况，改变的措施见第2节。

## 2.异步阻塞io

参考代码示例：ASyncBlockServer

流程说明：服务端接收一个连接，然后创建一个线程来处理这个socket信息，处理完关闭。

举例说明：饭店老板为了赚钱，于是又增加了桌子，并且新请了服务员，来一个客人就安排一个服务员进行服务。这种场景运行了一段时间后，饭店老板发现，这种模式请的服务员太多了，服务员并不需要一直陪着客人，在空闲时间可以给其他客人服务。于是老板又有了新的想法。改变措施见NIO。

# <2>.NIO  即NEW IO

## 1.异步阻塞io

参考代码示例：NioBlockServer

流程说明：通过创建多路复用器Selector，然后将ServerSocketChannel和SocketChannel注册到Selector中，注册时，需要指定channel感兴趣的事件，比如ServerSocketChannel的OP_ACCEPT(即连接请求)，SocketChannel的OP_READ(即读请求)。然后执行Selector的select方法(有相应的重载方法)，当注册其中的Channel有感兴趣的事件就绪时，通过Selector的selectedKeys方法可以获取到就绪的事件，然后对继续的事件进行处理。

举例说明：饭店老板专门招了一个人，这个人用来通知饭店经理和服务员，饭店经理主要用来给顾客安排位置，服务员主要用来服务顾客的需求

1.当顾客进门，招待员通过饭店经理来人了，你出来干活吧，饭店经理将顾客引导至相应的座位上。

2.当顾客在座位上，看过菜单决定点菜时，招待员通知服务员过来服务顾客，服务员给顾客服务。

# <3>.AIO  即非阻塞 IO

## 1.异步非阻塞io

参考代码示例：AioNonBlockServer

流程说明：AIO采用事件通知机制，通过不断的循环注册事件实现连接、数据的读取操作。

举例说明：这就好比去自助餐厅吃饭，自助餐厅门口设置了门禁，只有支付费用后门禁打开，可以进去大吃大喝了；顾客进入餐厅后，做到座位后，指定一个事件，我需要那些吃的，你们帮我拿过来吧。



